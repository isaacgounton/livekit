# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

### Building
- `mage build` - Build the LiveKit server binary (default target)
- `mage buildlinux` - Build binary that runs on Linux (amd64 by default, set GOARCH env var for other architectures)
- `./bootstrap.sh` - Install dependencies and set up build environment (run once)

### Testing
- `mage test` - Run unit tests only (fast, skips integration)
- `mage testall` - Run all tests including integration tests (slower, more comprehensive)
- `go test ./pkg/rtc -v` - Run tests for a specific package
- `go test -run TestSpecificFunction ./pkg/somepackage` - Run a specific test function

### Code Generation & Maintenance
- `mage generate` - Regenerate all code (including Wire dependency injection)
- `mage clean` - Clean build artifacts
- `go generate ./...` - Generate code for all packages
- `go mod tidy` - Clean up module dependencies

### Deadlock Detection (Development)
- `mage deadlock` - Replace sync.Mutex with deadlock.Mutex for deadlock detection
- `mage sync` - Restore sync.Mutex from deadlock.Mutex

## Architecture Overview

LiveKit is a distributed WebRTC SFU (Selective Forwarding Unit) written in Go. The architecture consists of several key layers:

### Core Components

**Server Entry Point** (`cmd/server/`)
- Main application entry point with CLI argument parsing
- Initializes all services and starts the server

**Service Layer** (`pkg/service/`)
- Uses Google Wire for dependency injection (see `wire_gen.go`)
- Core LiveKitServer implementation that orchestrates all components
- API handlers for room management, participant operations, and webhooks

**Real-Time Communication** (`pkg/rtc/`)
- Core WebRTC functionality including participants, rooms, and media tracks
- Transport management for peer connections
- Subscription management and media forwarding
- Dynamically adaptive quality management (`dynacast/`)

**Routing Layer** (`pkg/routing/`)
- Handles routing of participants to appropriate server nodes
- Supports both local and Redis-based routing
- Signal management for real-time communication
- Node selection algorithms (CPU load, region-aware, sysload)

**SFU Engine** (`pkg/sfu/`)
- Selective Forwarding Unit implementation
- Media stream forwarding and routing
- RTP/RTCP packet handling

### Key Dependencies

- **Pion WebRTC** - WebRTC implementation in Go
- **Google Wire** - Compile-time dependency injection
- **Redis** - Distributed routing and caching
- **gRPC/psrpc** - Inter-service communication
- **Prometheus** - Metrics and monitoring

### Configuration

Server configuration is handled through YAML files (see `config-sample.yaml`) and environment variables. The main config logic is in `pkg/config/`.

### Testing Strategy

- Unit tests are co-located with source files (`*_test.go`)
- Integration tests cover end-to-end scenarios
- Fakes generated by `counterfeiter` for interface testing
- Use `mage test` for quick feedback during development
- Use `mage testall` before submitting PRs

### Development Notes

- The project uses Go 1.24+ with toolchain 1.24.6
- Wire dependency injection is used extensively - regenerate with `mage generate` after changing interfaces
- Build outputs go to `bin/` directory
- The server supports both development (`--dev`) and production modes
- Extensive logging via zap logger with configurable levels